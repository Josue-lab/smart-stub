## Smart Stub

The Smart Stub provides some powerful capabilites:
* built-in swagger validation
* built-in state transition validation
* ability to prime responses

# Build instructions

sbt reload clean assembly   // build and run tests

sbt publish                 // publish jar to s3


## Usage
Engineers should create an Object (e.g. MyStub.scala) which extends SmartStub and then adds the following:


## Example
The project contains StubTests.scala which offers an example of mocking and test using SmartStub.

### A driver method
```
   def main(args : Array[String]) {
      // port, canned responses directory, swagger json file, state model file, opening state
      MyStub.configureStub(args(0).toInt, args(1), args(2), args(3), "registered")
      MyStub.start
   }
```
### Wiremock stub methods
```
    override def setUpMocks(cannedResponsesPath: String): Unit  = {

      wireMockServer.stubFor(post(urlMatching(".*/cars"))
             .withRequestBody(equalToJson("{\"action\":\"drive\"}",true,true))
             .willReturn(
               aResponse()
                 .withTransformerParameter("nextState", "moving")
                 .withBody("""{"response":"hello"}""")
                 .withStatus(200)));

        ...
    }
    
    The optional withTransformerParameter() method will indicate the state this action should place you in
    If you are not interested in state, use withTransformerParameter("nextState", "any") or omit the line.
    
```


### Prime next response
```
    doPost(url+MyStub.PRIMED_RESPONSE_URL+"?"+MyStub.RESPONSE_STATUS_QUERY_PARAM+"=200",  """{"response":"hello"}""")
    
    The next call to this stub will return this request's body and headers and the passed status
    
    You can create a series of responses by calling this multiple times and the stub will read FIFO
    
    Of course, if you have a wiremock handle, you can  add mock stubs on the fly using the wiremock API.
    
```

The swagger json file will be generated by swagger

If you don;t want to validate state just use .withTransformerParameter("nextState", "any")

The state model json will be of the following format:
```
   {
     "stateTransitions": [
         {
           "prestate": "<some state>",
           "poststate": "<some state>"
         },
         {
           "prestate": "<some state>",
           "poststate": "<some state>"
         }
     ]
   }
```
## Errors
* An invalid request payload will return a 500 with an error
* An invalid response (from the stub) will also result in a 500 with an error
* An invalid state transition will (you guessed it) return a 500 with an error


## Test Design
You should run your acceptance tests against the stub as well as the real service
to further improve the validity of the stub, as well as validating the test requests
against swagger.

The state model and the swagger schema should be common across the application and the stub

## License

This project is licensed under the APACHE License - see the LICENSE file for details

## Acknowledgments

The awesome Wiremock team
