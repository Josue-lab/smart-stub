## Smart Stub

# Build instructions
sbt reload clean assembly
sbt publish  // publish jar to s3


## Usage
Engineers should create an Object (e.g. MyStub.scala) which extends SmartStub and then adds the following:

### A driver method
```
   def main(args : Array[String]) {
      // port, canned responses directory, swagger json file, state model file, opening state
      MyStub.configureStub(args(0).toInt, args(1), args(2), args(3), "registered")
      MyStub.start
   }
```
### Wiremock stub methods
```
    override def setUpMocks(cannedResponsesPath: String): Unit  = {

        wireMockServer.stubFor(post(urlMatching(".*/hello"))
         .willReturn(
           aResponse()
             .withHeader("Content-Type", "application/json")
             .withBody("""{"hello":"world"}""")
             .withStatus(200)))

        ...
    }
```
The swagger json file will be generated by swagger

The state model json will be of the following format:
```
   {
     "stateTransitions": [
         {
           "action": "post",
           "prestate": "<some state>",
           "poststate": "<some state>"
         },
         {
           "action": "get",
           "prestate": "<some state>",
           "poststate": "<some state>"
         }
     ]
   }

   where 'action' is the rest action
```
## Errors
* An invalid request payload will return a 500 with an error
* An invalid response (from the stub) will also result in a 500 with an error
* An invalid state transition will (you guessed it) return a 500 with an error


## Test Design
You should run your acceptance tests against the stub as well as the real service
to further improve the validity of the stub, as well as validating the test requests
against swagger.

The state model and the swagger schema should be common across the application and the stub

## License

This project is licensed under the APACHE License - see the [LICENSE.md](LICENSE.md) file for details

## Acknowledgments

The awesome Wiremock team
